
import { register, permutateThemes } from '@tokens-studio/sd-transforms';
import StyleDictionary from 'style-dictionary';
import { promises } from 'fs';
import path from 'path';

// Register Tokens Studio transforms with Style Dictionary
register(StyleDictionary, {
    
});

// Helper to format the file header
async function fileHeader({ file }) {
    return `// Do not edit directly. Generated by Style Dictionary.\n// File: ${file.destination}\n\n`;
  }
  
  function formattedVariables({ dictionary }) {
    return dictionary.allTokens.map((prop) => {
      let value = prop.$value;
      const type = prop.$type;
  
      // Handle undefined values
      if (value === undefined) {
        console.warn(`Token ${prop.name} has an undefined value.`);
        return `  // Token ${prop.name} has an undefined value`;
      }

      // Handle font weights
    if (type === 'fontWeights') {
        const weightMap = {
          thin: 'FontWeight.w100',
          extralight: 'FontWeight.w200',
          light: 'FontWeight.w300',
          regular: 'FontWeight.w400',
          medium: 'FontWeight.w500',
          semibold: 'FontWeight.w600',
          bold: 'FontWeight.w700',
          extrabold: 'FontWeight.w800',
          black: 'FontWeight.w900',
        };
        value = weightMap[value.toLowerCase()] || 'FontWeight.w400'; // Default to regular
        return `  static const ${prop.name} = ${value};`;
      }
  
      // Handle RGBA colors
      if (type === 'color' && value.startsWith('rgba')) {
        const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (match) {
          const [, r, g, b, a] = match;
          const alpha = Math.round(parseFloat(a) * 255).toString(16).padStart(2, '0');
          value = `Color(0x${alpha}${parseInt(r).toString(16).padStart(2, '0')}${parseInt(g).toString(16).padStart(2, '0')}${parseInt(b).toString(16).padStart(2, '0')})`;
        }
        return `  static const ${prop.name} = ${value};`;
      }
  
      // Handle boxShadow (arrays of objects)
      if (type === 'boxShadow' && Array.isArray(value)) {
        value = value.map((shadow) => {
          const color = shadow.color || 'Colors.transparent';
          const x = shadow.x || 0;
          const y = shadow.y || 0;
          const blur = shadow.blur || 0;
          const spread = shadow.spread || 0;
          return `BoxShadow(color: ${color}, offset: Offset(${x}, ${y}), blurRadius: ${blur}, spreadRadius: ${spread})`;
        }).join(', ');
        return `  static const ${prop.name} = [${value}];`;
      }
  
      // Handle typography
      if (type === 'typography' && typeof value === 'object') {
        const fontFamily = value.fontFamily || '""';
        const fontWeight = value.fontWeight || 'FontWeight.normal';
        const lineHeight = value.lineHeight || '1.0';
        const fontSize = value.fontSize || '12.0';
        const letterSpacing = value.letterSpacing || '0.0';
        return `  static const ${prop.name} = TextStyle(fontFamily: ${fontFamily}, fontWeight: ${fontWeight}, height: ${lineHeight}, fontSize: ${fontSize}, letterSpacing: ${letterSpacing});`;
      }
  
      // Handle other types (color, dimension, etc.)
      if (type === 'color') {
        value = `${value.replace('#', '')}`;
      } else if (type === 'dimension') {
        value = `${parseFloat(value)}.0`;
      } else if (typeof value === 'string') {
        value = `'${value}'`;
      }
  
      return `  static const ${prop.name} = ${value};`;
    }).join('\n');
  }
  
  // Register the custom format
  StyleDictionary.registerFormat({
    name: 'custom/flutter/class.dart',
    format: async ({ dictionary, file, options }) => {
      const { className } = options;
      const header = await fileHeader({ file });
      const variables = formattedVariables({ dictionary });
  
      return (
        `${header}import 'dart:ui';\n\n` +
        `class ${className} {\n` +
        `  ${className}._();\n\n` +
        `${variables}\n` +
        `}`
      );
    },
  });

// Function to validate input files
async function validateInputs(tokensets) {
  for (const tokenset of tokensets) {
    const filePath = path.join(tokenset);
    try {
      await promises.access(filePath);
    } catch (error) {
      throw new Error(`Input file not found: ${filePath}`);
    }
  }
}

async function run() {
  // Load the themes file
  const $themes = JSON.parse(await promises.readFile('assets/design-tokens/$themes.json', 'utf-8'));

  // Permutate themes to create different token sets
  const permutedThemes = permutateThemes($themes, { separator: '_' });

  const themes = {
    default_light: permutedThemes.Light_Light,
    default_dark: permutedThemes.Light_Dark,
    igraal_light: permutedThemes.Dark_Light,
    igraal_dark: permutedThemes.Dark_Dark
}; 
  // Create configuration for each theme set
  const configs = Object.entries(themes).map(([name, tokensets]) => ({
    source: tokensets.map(tokenset => path.join('assets/design-tokens', tokenset + '.json')),
    platforms: {
        flutter: {
            transformGroup: 'flutter',
            transforms: ['attribute/cti', 'name/camel', 'color/hex'],
            buildPath: 'build/flutter/',
            files: [{
              destination: `theme_${name}.dart`,
              format: 'custom/flutter/class.dart',
              options: {
                outputReferences: false,
                className: `Theme${name.charAt(0).toUpperCase() + name.slice(1)}`,
              }
            }]
        }
    }
  }));

  // Set log verbosity to verbose

  // Validate inputs and build for each theme configuration
  for (const config of configs) {
    await validateInputs(config.source);
    const sd = new StyleDictionary(config);
    sd.buildAllPlatforms();
  }

  console.log('Flutter variable files generated successfully!');
}

run();
